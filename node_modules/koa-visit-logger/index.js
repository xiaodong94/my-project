/**
 * Module dependencies.
 */

const Counter = require('passthrough-counter')
const bytes = require('bytes')
const chalk = require('chalk')
const fs = require('fs')
const humanize = require('humanize-number')
const mkdirp = require('mkdirp')
const path = require('path')
const util = require('util')
const winston = require('winston')
require('winston-daily-rotate-file')

const colorCodes = {
  7: 'magenta',
  5: 'red',
  4: 'yellow',
  3: 'cyan',
  2: 'green',
  1: 'green',
  0: 'yellow'
}

const regex = /\.(?:js|css|png|ico|bmp|jpg|jpeg|gif|webp|jpe)/ig
const origin = ['method', 'original', 'status', 'time', 'size']

const development = process.env.NODE_ENV === 'development'
const production = process.env.NODE_ENV === 'production'
const env = !(development || production)
const localPath = path.join(path.dirname(__dirname), '../logs')
const servePath = '/data/logs/'
const domain = !env ? servePath : localPath

const defaults = {
  appName: 'app',
  dailyRotateFile: {
    datePattern: 'YYYY.MM.DD.HH',
    maxSize: '100m',
    maxFiles: '15d'
  },
  domain,
  fileName: 'app',
  handler: null,
  transporter: null
}

/**
 * VisitLogger.
 */

function visitLogger (opts) {
  const options = Object.assign({}, defaults, opts)
  let logsPath = path.join(options.domain, options.appName)

  // log output directory
  if (!fs.existsSync(logsPath)) {
    try {
      mkdirp.sync(logsPath)
    } catch (err) {
      console.error(`Create '${servePath}' directory is failure!`)
      logsPath = path.join(localPath, options.appName)
      mkdirp.sync(logsPath)
    }
  }

  const { datePattern, maxFiles, maxSize } = options.dailyRotateFile

  const visit = winston.createLogger({
    level: 'verbose',
    format: winston.format.json(),
    transports: [
      new (winston.transports.DailyRotateFile)({
        datePattern,
        filename: path.join(logsPath, `${options.fileName}.verbose.%DATE%.log`),
        maxFiles,
        maxSize
      })
    ]
  })

  // print to console helper.
  const print = config => {
    if (config.source) {
      const basic = {}

      config.other.forEach((element, key) => {
        basic[origin[key]] = element
      })

      if (typeof options.handler === 'function') {
        config.notes.handler = options.handler(config.origin)
      }

      visit.verbose({
        basic,
        notes: config.notes
      })
    }

    if (env) {
      if (typeof options.transporter === 'function') {
        options.transporter(config)
      } else {
        const string = util.format(config.string, ...config.other)
        console.log(string)
      }
    }
  }

  return async (ctx, next) => {
    // request
    const start = ctx[Symbol.for('request-received.startTime')]
      ? ctx[Symbol.for('request-received.startTime')].getTime() : Date.now()

    if (!regex.test(ctx.href)) {
      const string = `${chalk.gray('<--')} ${chalk.bold('%s')} ${chalk.gray('%s')}`

      print({
        string,
        source: false,
        other: [
          ctx.method,
          ctx.originalUrl
        ]
      })
    }

    try {
      await next()
    } catch (err) {
      // log uncaught downstream errors
      console.error(err)
      logger(print, ctx, start, null, err)
    }

    // calculate the length of a streaming response
    // by intercepting the stream with a counter.
    // only necessary if a content-length header is currently not set.
    const { length } = ctx.response
    const { body } = ctx
    let counter

    if (length == null && body && body.readable) {
      ctx.body = body.pipe(counter = Counter()).on('error', ctx.onerror)
    }

    // log when the response is finished or closed,
    // whichever happens first.
    const { res } = ctx

    const onfinish = done.bind(null, 'finish')
    const onclose = done.bind(null, 'close')

    res.once('finish', onfinish)
    res.once('close', onclose)

    function done (event) {
      res.removeListener('finish', onfinish)
      res.removeListener('close', onclose)

      if (!regex.test(ctx.href)) {
        logger(print, ctx, start, counter ? counter.length : length, null, event)
      }
    }
  }
}

/**
 * Logger helper.
 */

function logger (print, ctx, start, len, err, event) {
  // get the status code of the response
  const status = err
    ? (err.isBoom ? err.output.statusCode : err.status || 500)
    : (ctx.status || 404)

  // set the color of the status code;
  // eslint-disable-next-line
  const s = status / 100 | 0
  // eslint-disable-next-line
  const color = colorCodes.hasOwnProperty(s) ? colorCodes[s] : colorCodes[0]

  // get the human readable response length
  let length

  if (~[204, 205, 304].indexOf(status)) {
    length = ''
  } else if (len == null) {
    length = '-'
  } else {
    length = bytes(len).toLowerCase()
  }

  const upstream = err ? chalk.red('xxx')
    : event === 'close' ? chalk.yellow('-x-')
      : chalk.gray('-->')

  const string = `${upstream} ${
    chalk.bold('%s')} ${
    chalk.gray('%s')} ${
    chalk[color]('%s')} ${
    chalk.gray('%s')} ${
    chalk.gray('%s')}`

  const data = {
    string,
    source: true,
    origin: ctx,
    other: [
      ctx.method,
      ctx.originalUrl,
      status,
      time(start),
      length
    ],
    notes: {
      href: ctx.href,
      request: {
        header: ctx.request.header
      },
      response: {
        status: ctx.status,
        message: ctx.message,
        header: {
          'content-type': ctx.type,
          'content-length': ctx.length
        }
      }
    }
  }

  if (ctx.response.is('application/json')) {
    // data.notes.response.body = (ctx.body && JSON.parse(ctx.body)) || ''
    data.notes.response.body = ctx.body || ''
  }

  print(data)
}

/**
 * Show the response time in a human readable format.
 * In milliseconds if less than 10 seconds,
 * in seconds otherwise.
 */

function time (start) {
  const delta = Date.now() - start
  return humanize(delta < 10000
    ? `${delta}ms`
    : `${Math.round(delta / 1000)}s`)
}

/**
 * Expose logger.
 */

module.exports = visitLogger
